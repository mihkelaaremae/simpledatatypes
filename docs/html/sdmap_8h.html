<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simple dynamic datatypes: C:/Users/Mihkel/Documents/Projects/simpledatatypes/include/sdmap.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Simple dynamic datatypes
   </div>
   <div id="projectbrief">Simple dynamic datatypes for C</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle"><div class="title">sdmap.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;assert.h&gt;</code><br />
</div>
<p><a href="sdmap_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a027d5bbb69571849cbefb5625e0aee65"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sdmap_8h.html#a027d5bbb69571849cbefb5625e0aee65">SDMAP_DEFAULT_CAPACITY</a>&#160;&#160;&#160;16</td></tr>
<tr class="separator:a027d5bbb69571849cbefb5625e0aee65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99abb33e73739188501f04327cd6b8e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sdmap_8h.html#ac99abb33e73739188501f04327cd6b8e">SDMAP_SHRINK_DENOMINATOR</a>&#160;&#160;&#160;4.0</td></tr>
<tr class="separator:ac99abb33e73739188501f04327cd6b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18bb960e83e03951b43c8091f2031dfa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sdmap_8h.html#a18bb960e83e03951b43c8091f2031dfa">SDMAP_ENABLE_AUTOSHRINK</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a18bb960e83e03951b43c8091f2031dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abccb263f6ef93f0b81390a418d3f378e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sdmap_8h.html#abccb263f6ef93f0b81390a418d3f378e">sdmap_malloc</a>&#160;&#160;&#160;malloc</td></tr>
<tr class="separator:abccb263f6ef93f0b81390a418d3f378e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab022021ac52ab2e5aa72b84dfe2994e4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sdmap_8h.html#ab022021ac52ab2e5aa72b84dfe2994e4">sdmap_realloc</a>&#160;&#160;&#160;realloc</td></tr>
<tr class="separator:ab022021ac52ab2e5aa72b84dfe2994e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08e085dfdb64d3ee572c01a7b974e92"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sdmap_8h.html#ab08e085dfdb64d3ee572c01a7b974e92">sdmap_free</a>&#160;&#160;&#160;free</td></tr>
<tr class="separator:ab08e085dfdb64d3ee572c01a7b974e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013ed3da333fd5db262d063b26eb717d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sdmap_8h.html#a013ed3da333fd5db262d063b26eb717d">sdmap_assert</a>&#160;&#160;&#160;assert</td></tr>
<tr class="separator:a013ed3da333fd5db262d063b26eb717d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4ca89b98884034d59f19eef7a85ca3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sdmap_8h.html#a3d4ca89b98884034d59f19eef7a85ca3">sdmap_index_t</a>&#160;&#160;&#160;uint32_t</td></tr>
<tr class="separator:a3d4ca89b98884034d59f19eef7a85ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfffa2bea0be7ffdf1677096718f72a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sdmap_8h.html#a9bfffa2bea0be7ffdf1677096718f72a">sdmap_typeof</a>&#160;&#160;&#160;__typeof__</td></tr>
<tr class="separator:a9bfffa2bea0be7ffdf1677096718f72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6824b46342ace03c477fc71c66271e31"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sdmap_8h.html#a6824b46342ace03c477fc71c66271e31">sdmap</a>(key_type,  value_type)</td></tr>
<tr class="memdesc:a6824b46342ace03c477fc71c66271e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap-type simple dynamic map type generator.  <br /></td></tr>
<tr class="separator:a6824b46342ace03c477fc71c66271e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae441701f375f9a200aea81c465c2d8da"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sdmap_8h.html#ae441701f375f9a200aea81c465c2d8da">sdmap_stack</a>(key_type,  value_type,  element_count)</td></tr>
<tr class="memdesc:ae441701f375f9a200aea81c465c2d8da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack-type simple dynamic map type generator.  <br /></td></tr>
<tr class="separator:ae441701f375f9a200aea81c465c2d8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61115c6087da074045186992152febee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sdmap_8h.html#a61115c6087da074045186992152febee">sdmap_count</a>(map)</td></tr>
<tr class="memdesc:a61115c6087da074045186992152febee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the amount of elements in the map.  <br /></td></tr>
<tr class="separator:a61115c6087da074045186992152febee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad8071bdddc61416b1d7217a0c96eec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sdmap_8h.html#adad8071bdddc61416b1d7217a0c96eec">sdmap_capacity</a>(map)</td></tr>
<tr class="memdesc:adad8071bdddc61416b1d7217a0c96eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the amount of elements the map can store currently.  <br /></td></tr>
<tr class="separator:adad8071bdddc61416b1d7217a0c96eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b15c32cd209c23b0209b532ae4761b1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sdmap_8h.html#a0b15c32cd209c23b0209b532ae4761b1">sdmap_contains</a>(map,  key_expr)</td></tr>
<tr class="memdesc:a0b15c32cd209c23b0209b532ae4761b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a key exists in the map.  <br /></td></tr>
<tr class="separator:a0b15c32cd209c23b0209b532ae4761b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883ff248816a4f332d49587b7840a444"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sdmap_8h.html#a883ff248816a4f332d49587b7840a444">sdmap_reserve</a>(map,  capacity)</td></tr>
<tr class="memdesc:a883ff248816a4f332d49587b7840a444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve enough space to fill capacity elements.  <br /></td></tr>
<tr class="separator:a883ff248816a4f332d49587b7840a444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cef0a813ffbfeca143b1252b993b074"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sdmap_8h.html#a5cef0a813ffbfeca143b1252b993b074">sdmap_new</a>(...)</td></tr>
<tr class="memdesc:a5cef0a813ffbfeca143b1252b993b074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new map.  <br /></td></tr>
<tr class="separator:a5cef0a813ffbfeca143b1252b993b074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267d1e897c6a2c25482a804dff0efa4f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sdmap_8h.html#a267d1e897c6a2c25482a804dff0efa4f">sdmap_duplicate</a>(map,  source)</td></tr>
<tr class="memdesc:a267d1e897c6a2c25482a804dff0efa4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate an existing map.  <br /></td></tr>
<tr class="separator:a267d1e897c6a2c25482a804dff0efa4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae88efd1bcf9c22198e7845ab6928d2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sdmap_8h.html#abae88efd1bcf9c22198e7845ab6928d2">sdmap_get</a>(map,  key_expr)</td></tr>
<tr class="memdesc:abae88efd1bcf9c22198e7845ab6928d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a value associated with a key, if key doesn't exist then inserts an element.  <br /></td></tr>
<tr class="separator:abae88efd1bcf9c22198e7845ab6928d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad448ee70d29eafd9f054b2a61379259c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sdmap_8h.html#ad448ee70d29eafd9f054b2a61379259c">sdmap_set</a>(map,  key_expr,  value_expr)</td></tr>
<tr class="memdesc:ad448ee70d29eafd9f054b2a61379259c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a value to a key. If the key already exists in the map, then it is overwritten.  <br /></td></tr>
<tr class="separator:ad448ee70d29eafd9f054b2a61379259c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab927e5fc44e3ba18d843e9a27aa5f75e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sdmap_8h.html#ab927e5fc44e3ba18d843e9a27aa5f75e">sdmap_getp</a>(map,  key_expr)</td></tr>
<tr class="memdesc:ab927e5fc44e3ba18d843e9a27aa5f75e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a pointer to a value associated with a key, if key doesn't exist returns NULL.  <br /></td></tr>
<tr class="separator:ab927e5fc44e3ba18d843e9a27aa5f75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b3b434ef67ee002598f23a70ade531"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sdmap_8h.html#ab9b3b434ef67ee002598f23a70ade531">sdmap_erase</a>(map,  key_expr)</td></tr>
<tr class="memdesc:ab9b3b434ef67ee002598f23a70ade531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a key from the map. If the key doesn't exist, then nothing is done.  <br /></td></tr>
<tr class="separator:ab9b3b434ef67ee002598f23a70ade531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a7508b5465c4dbb1f41f4e50ecc3ed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sdmap_8h.html#a27a7508b5465c4dbb1f41f4e50ecc3ed">sdmap_shrink</a>(map)</td></tr>
<tr class="memdesc:a27a7508b5465c4dbb1f41f4e50ecc3ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize and shrink the map down as much as possible.  <br /></td></tr>
<tr class="separator:a27a7508b5465c4dbb1f41f4e50ecc3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d92a70c1b420aa797c293a8095410ce"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sdmap_8h.html#a6d92a70c1b420aa797c293a8095410ce">sdmap_min</a>(map)</td></tr>
<tr class="memdesc:a6d92a70c1b420aa797c293a8095410ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a pointer to the smallest key.  <br /></td></tr>
<tr class="separator:a6d92a70c1b420aa797c293a8095410ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9200165d705be1deec29e85c787a5b2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sdmap_8h.html#ab9200165d705be1deec29e85c787a5b2">sdmap_max</a>(map)</td></tr>
<tr class="memdesc:ab9200165d705be1deec29e85c787a5b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a pointer to the largest key.  <br /></td></tr>
<tr class="separator:ab9200165d705be1deec29e85c787a5b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee79904f24eff7f229af6e0ba6fee82"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sdmap_8h.html#a2ee79904f24eff7f229af6e0ba6fee82">sdmap_root</a>(map)</td></tr>
<tr class="memdesc:a2ee79904f24eff7f229af6e0ba6fee82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a pointer to the root key.  <br /></td></tr>
<tr class="separator:a2ee79904f24eff7f229af6e0ba6fee82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574eb76811a4e7a9812a9955b58f5fb8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sdmap_8h.html#a574eb76811a4e7a9812a9955b58f5fb8">sdmap_next</a>(map,  key_expr)</td></tr>
<tr class="memdesc:a574eb76811a4e7a9812a9955b58f5fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a pointer to the key that comes after key.  <br /></td></tr>
<tr class="separator:a574eb76811a4e7a9812a9955b58f5fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4dc757bbf950ce4ecb06d264fc60b0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sdmap_8h.html#adc4dc757bbf950ce4ecb06d264fc60b0">sdmap_prev</a>(map,  key_expr)</td></tr>
<tr class="memdesc:adc4dc757bbf950ce4ecb06d264fc60b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a pointer to the key that comes before key.  <br /></td></tr>
<tr class="separator:adc4dc757bbf950ce4ecb06d264fc60b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90aef422e096c1a030bfcc5c780c52c2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sdmap_8h.html#a90aef422e096c1a030bfcc5c780c52c2">sdmap_traverse_inorder_keys</a>(map, ...)</td></tr>
<tr class="memdesc:a90aef422e096c1a030bfcc5c780c52c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the map in order and look at keys.  <br /></td></tr>
<tr class="separator:a90aef422e096c1a030bfcc5c780c52c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0217ef11d095b9aead6a94089ef9b4ed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sdmap_8h.html#a0217ef11d095b9aead6a94089ef9b4ed">sdmap_traverse_preorder_keys</a>(map, ...)</td></tr>
<tr class="memdesc:a0217ef11d095b9aead6a94089ef9b4ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the map in pre order and look at keys.  <br /></td></tr>
<tr class="separator:a0217ef11d095b9aead6a94089ef9b4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7117505991ec288cce345978dfb83c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sdmap_8h.html#a0b7117505991ec288cce345978dfb83c">sdmap_traverse_inorder_values</a>(map, ...)</td></tr>
<tr class="memdesc:a0b7117505991ec288cce345978dfb83c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the map in order and look at values.  <br /></td></tr>
<tr class="separator:a0b7117505991ec288cce345978dfb83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea7149f681bf40d37d2abe7974cc1cac"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sdmap_8h.html#aea7149f681bf40d37d2abe7974cc1cac">sdmap_traverse_preorder_values</a>(map, ...)</td></tr>
<tr class="memdesc:aea7149f681bf40d37d2abe7974cc1cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the map in preorder and look at values.  <br /></td></tr>
<tr class="separator:aea7149f681bf40d37d2abe7974cc1cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1785d8573b9b1af793006080a0e7d8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sdmap_8h.html#a4a1785d8573b9b1af793006080a0e7d8">sdmap_traverse_inorder_pairs</a>(map, ...)</td></tr>
<tr class="memdesc:a4a1785d8573b9b1af793006080a0e7d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the map in order and look at both keys and values.  <br /></td></tr>
<tr class="separator:a4a1785d8573b9b1af793006080a0e7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7cf928e5e3c5e880fd0c7b16cab8b1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sdmap_8h.html#a2c7cf928e5e3c5e880fd0c7b16cab8b1">sdmap_traverse_preorder_pairs</a>(map, ...)</td></tr>
<tr class="memdesc:a2c7cf928e5e3c5e880fd0c7b16cab8b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the map in preorder and look at both keys and values.  <br /></td></tr>
<tr class="separator:a2c7cf928e5e3c5e880fd0c7b16cab8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8713226f2dcc338237aedf3277d3724"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sdmap_8h.html#ac8713226f2dcc338237aedf3277d3724">sdmap_delete</a>(map)</td></tr>
<tr class="memdesc:ac8713226f2dcc338237aedf3277d3724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free and invalidate map.  <br /></td></tr>
<tr class="separator:ac8713226f2dcc338237aedf3277d3724"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Simple dynamic map object implemented with AVL trees for C. </p><dl class="section date"><dt>Date</dt><dd>04. Feb 2023 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Mihkel Aaremäe </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a6824b46342ace03c477fc71c66271e31" name="a6824b46342ace03c477fc71c66271e31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6824b46342ace03c477fc71c66271e31">&#9670;&#160;</a></span>sdmap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sdmap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value_type&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Heap-type simple dynamic map type generator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_type</td><td>Type of the key in the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value_type</td><td>Type of the value in the map.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Type to sdmap object that satisfies the input parameters </dd></dl>

</div>
</div>
<a id="a013ed3da333fd5db262d063b26eb717d" name="a013ed3da333fd5db262d063b26eb717d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a013ed3da333fd5db262d063b26eb717d">&#9670;&#160;</a></span>sdmap_assert</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sdmap_assert&#160;&#160;&#160;assert</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A user-defineable macro that should have the same prototype and functionality as <code>assert</code>, defaults to <code>assert</code> or <code>sdd_assert</code> if defined. </p>

</div>
</div>
<a id="adad8071bdddc61416b1d7217a0c96eec" name="adad8071bdddc61416b1d7217a0c96eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adad8071bdddc61416b1d7217a0c96eec">&#9670;&#160;</a></span>sdmap_capacity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sdmap_capacity</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the amount of elements the map can store currently. </p>
<p>Average time complexity - <code>O(1)</code><br  />
 When map is a heap-type map then the capacity will be grown automatically to make space for more elements.<br  />
 For stack-type maps the capacity is fixed and cannot be changed. Attempting to do so by adding more elements will trip an assert.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>Map object to retrieve the capacity from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Capacity of map, counted in elements <code>(sdmap_index_t)</code>. </dd></dl>

</div>
</div>
<a id="a0b15c32cd209c23b0209b532ae4761b1" name="a0b15c32cd209c23b0209b532ae4761b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b15c32cd209c23b0209b532ae4761b1">&#9670;&#160;</a></span>sdmap_contains</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sdmap_contains</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_expr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a key exists in the map. </p>
<p>Average time complexity -<br  />
 <code>O(log(count))</code><br  />
 <code>O(1)</code> if <code>key_expr</code> is a pointer retrieved by any function in this library.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>Map to perform the test on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_expr</td><td>Either a key or a pointer to a key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Does the element exist in the map <code>(int)</code>. </dd></dl>

</div>
</div>
<a id="a61115c6087da074045186992152febee" name="a61115c6087da074045186992152febee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61115c6087da074045186992152febee">&#9670;&#160;</a></span>sdmap_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sdmap_count</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the amount of elements in the map. </p>
<p>Average time complexity - <code>O(1)</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>Map object to retrieve the count from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Amount of elements in map <code>(sdmap_index_t)</code>. </dd></dl>

</div>
</div>
<a id="a027d5bbb69571849cbefb5625e0aee65" name="a027d5bbb69571849cbefb5625e0aee65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a027d5bbb69571849cbefb5625e0aee65">&#9670;&#160;</a></span>SDMAP_DEFAULT_CAPACITY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SDMAP_DEFAULT_CAPACITY&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default amount of elements to allocate when none are specified. </p>

</div>
</div>
<a id="ac8713226f2dcc338237aedf3277d3724" name="ac8713226f2dcc338237aedf3277d3724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8713226f2dcc338237aedf3277d3724">&#9670;&#160;</a></span>sdmap_delete</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sdmap_delete</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free and invalidate map. </p>
<p>Average time complexity - same as <a class="el" href="sdmap_8h.html#ab08e085dfdb64d3ee572c01a7b974e92">sdmap_free</a> This function call may be omitted for stack type maps.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>Map object to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a267d1e897c6a2c25482a804dff0efa4f" name="a267d1e897c6a2c25482a804dff0efa4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a267d1e897c6a2c25482a804dff0efa4f">&#9670;&#160;</a></span>sdmap_duplicate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sdmap_duplicate</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">source&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate an existing map. </p>
<p>Average time complexity - <code>O(count)</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>Destination map </td></tr>
    <tr><td class="paramname">source</td><td>Source map </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18bb960e83e03951b43c8091f2031dfa" name="a18bb960e83e03951b43c8091f2031dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18bb960e83e03951b43c8091f2031dfa">&#9670;&#160;</a></span>SDMAP_ENABLE_AUTOSHRINK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SDMAP_ENABLE_AUTOSHRINK&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Should all maps be shrinked automatically following erase operations. See <a class="el" href="sdmap_8h.html#ac99abb33e73739188501f04327cd6b8e">SDMAP_SHRINK_DENOMINATOR</a> for more info. </p>

</div>
</div>
<a id="ab9b3b434ef67ee002598f23a70ade531" name="ab9b3b434ef67ee002598f23a70ade531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9b3b434ef67ee002598f23a70ade531">&#9670;&#160;</a></span>sdmap_erase</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sdmap_erase</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_expr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase a key from the map. If the key doesn't exist, then nothing is done. </p>
<p>Average time complexity -<br  />
 <code>O(log(count))</code><br  />
 <code>O(1)</code> if <code>key_expr</code> is a pointer retrieved by any function in this library. Calling this function invalidates all pointers retrieved with any function for this object in this library.<br  />
 This function will automatically shrink any heap-type maps when <a class="el" href="sdmap_8h.html#a18bb960e83e03951b43c8091f2031dfa">SDMAP_ENABLE_AUTOSHRINK</a> is defined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>Map to erase from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_expr</td><td>Either a key or a pointer to a key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab08e085dfdb64d3ee572c01a7b974e92" name="ab08e085dfdb64d3ee572c01a7b974e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab08e085dfdb64d3ee572c01a7b974e92">&#9670;&#160;</a></span>sdmap_free</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sdmap_free&#160;&#160;&#160;free</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A user-defineable macro that should have the same prototype and functionality as <code>free</code>, defaults to <code>free</code> or <code>sdd_free</code> if defined. </p>

</div>
</div>
<a id="abae88efd1bcf9c22198e7845ab6928d2" name="abae88efd1bcf9c22198e7845ab6928d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae88efd1bcf9c22198e7845ab6928d2">&#9670;&#160;</a></span>sdmap_get</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sdmap_get</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_expr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a value associated with a key, if key doesn't exist then inserts an element. </p>
<p>Average time complexity -<br  />
 <code>O(log(count))</code><br  />
 <code>O(1)</code> if <code>key_expr</code> is a pointer retrieved by any function in this library. Calling this function invalidates all pointers retrieved with any function for this object in this library.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>Map to perform the test on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_expr</td><td>Either a key or a pointer to a key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lvalue object associated with <code>key_expr</code> </dd></dl>

</div>
</div>
<a id="ab927e5fc44e3ba18d843e9a27aa5f75e" name="ab927e5fc44e3ba18d843e9a27aa5f75e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab927e5fc44e3ba18d843e9a27aa5f75e">&#9670;&#160;</a></span>sdmap_getp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sdmap_getp</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_expr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a pointer to a value associated with a key, if key doesn't exist returns NULL. </p>
<p>Average time complexity -<br  />
 <code>O(log(count))</code><br  />
 <code>O(1)</code> if <code>key_expr</code> is a pointer retrieved by any function in this library.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>Map to perform the test on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_expr</td><td>Either a key or a pointer to a key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to object associated with <code>key_expr</code>, NULL if key isn't found </dd></dl>

</div>
</div>
<a id="a3d4ca89b98884034d59f19eef7a85ca3" name="a3d4ca89b98884034d59f19eef7a85ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d4ca89b98884034d59f19eef7a85ca3">&#9670;&#160;</a></span>sdmap_index_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sdmap_index_t&#160;&#160;&#160;uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A user-defineable type for indexes in the map, defaults to <code>uint32_t</code>. </p>

</div>
</div>
<a id="abccb263f6ef93f0b81390a418d3f378e" name="abccb263f6ef93f0b81390a418d3f378e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abccb263f6ef93f0b81390a418d3f378e">&#9670;&#160;</a></span>sdmap_malloc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sdmap_malloc&#160;&#160;&#160;malloc</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A user-defineable macro that should have the same prototype and functionality as <code>malloc</code>, defaults to <code>malloc</code> or <code>sdd_malloc</code> if defined. </p>

</div>
</div>
<a id="ab9200165d705be1deec29e85c787a5b2" name="ab9200165d705be1deec29e85c787a5b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9200165d705be1deec29e85c787a5b2">&#9670;&#160;</a></span>sdmap_max</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sdmap_max</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a pointer to the largest key. </p>
<p>Average time complexity - <code>O(log(count))</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>Map to retrieve key from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to key, <code>NULL</code> if map is empty </dd></dl>

</div>
</div>
<a id="a6d92a70c1b420aa797c293a8095410ce" name="a6d92a70c1b420aa797c293a8095410ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d92a70c1b420aa797c293a8095410ce">&#9670;&#160;</a></span>sdmap_min</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sdmap_min</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a pointer to the smallest key. </p>
<p>Average time complexity - <code>O(log(count))</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>Map to retrieve key from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to key, <code>NULL</code> if map is empty </dd></dl>

</div>
</div>
<a id="a5cef0a813ffbfeca143b1252b993b074" name="a5cef0a813ffbfeca143b1252b993b074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cef0a813ffbfeca143b1252b993b074">&#9670;&#160;</a></span>sdmap_new</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sdmap_new</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new map. </p>
<p>Average time complexity - same as sdmap_malloc<br  />
 If map contains a previously used map then it should be freed with <code>sdmap_delete</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>Map to initialize </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>(OPTIONAL) compare function, should have the same prototype and functionality as the fourth parameter of <code>qsort</code>. Defaults to a library-generated function if key type is a basic type or <code>char *</code> (for strings). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>(OPTIONAL, OMITTED) amount of elements to reserve space for. Defaults to <a class="el" href="sdmap_8h.html#a027d5bbb69571849cbefb5625e0aee65">SDMAP_DEFAULT_CAPACITY</a>. This option is omitted for stack-type maps. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a574eb76811a4e7a9812a9955b58f5fb8" name="a574eb76811a4e7a9812a9955b58f5fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a574eb76811a4e7a9812a9955b58f5fb8">&#9670;&#160;</a></span>sdmap_next</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sdmap_next</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_expr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a pointer to the key that comes after key. </p>
<p>Average time complexity -<br  />
 <code>O(log(count))</code><br  />
 <code>O(1)</code> if <code>key_expr</code> is a pointer retrieved by any function in this library.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>Map to retrieve key from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_expr</td><td>Either a key or a pointer to a key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to key, <code>NULL</code> if map is empty or key is largest in map </dd></dl>

</div>
</div>
<a id="adc4dc757bbf950ce4ecb06d264fc60b0" name="adc4dc757bbf950ce4ecb06d264fc60b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc4dc757bbf950ce4ecb06d264fc60b0">&#9670;&#160;</a></span>sdmap_prev</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sdmap_prev</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_expr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a pointer to the key that comes before key. </p>
<p>Average time complexity -<br  />
 <code>O(log(count))</code><br  />
 <code>O(1)</code> if <code>key_expr</code> is a pointer retrieved by any function in this library.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>Map to retrieve key from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_expr</td><td>Either a key or a pointer to a key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to key, <code>NULL</code> if map is empty or key is largest in map </dd></dl>

</div>
</div>
<a id="ab022021ac52ab2e5aa72b84dfe2994e4" name="ab022021ac52ab2e5aa72b84dfe2994e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab022021ac52ab2e5aa72b84dfe2994e4">&#9670;&#160;</a></span>sdmap_realloc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sdmap_realloc&#160;&#160;&#160;realloc</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A user-defineable macro that should have the same prototype and functionality as <code>realloc</code>, defaults to <code>realloc</code> or <code>sdd_realloc</code> if defined. </p>

</div>
</div>
<a id="a883ff248816a4f332d49587b7840a444" name="a883ff248816a4f332d49587b7840a444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a883ff248816a4f332d49587b7840a444">&#9670;&#160;</a></span>sdmap_reserve</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sdmap_reserve</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">capacity&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserve enough space to fill capacity elements. </p>
<p>Average time complexity - same as sdmap_realloc<br  />
 Calling this function invalidates all pointers retrieved with any function for this object in this library.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>Map to reserve space for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>Amount of elements to reserve space for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ee79904f24eff7f229af6e0ba6fee82" name="a2ee79904f24eff7f229af6e0ba6fee82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ee79904f24eff7f229af6e0ba6fee82">&#9670;&#160;</a></span>sdmap_root</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sdmap_root</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a pointer to the root key. </p>
<p>Average time complexity - <code>O(1)</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>Map to retrieve key from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to key, <code>NULL</code> if map is empty </dd></dl>

</div>
</div>
<a id="ad448ee70d29eafd9f054b2a61379259c" name="ad448ee70d29eafd9f054b2a61379259c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad448ee70d29eafd9f054b2a61379259c">&#9670;&#160;</a></span>sdmap_set</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sdmap_set</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_expr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value_expr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a value to a key. If the key already exists in the map, then it is overwritten. </p>
<p>Average time complexity -<br  />
 <code>O(log(count))</code><br  />
 <code>O(1)</code> if <code>key_expr</code> is a pointer retrieved by any function in this library. Calling this function invalidates all pointers retrieved with any function for this object in this library.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>Map to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_expr</td><td>Either a key or a pointer to a key </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value_expr</td><td>Value to associate the key to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27a7508b5465c4dbb1f41f4e50ecc3ed" name="a27a7508b5465c4dbb1f41f4e50ecc3ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27a7508b5465c4dbb1f41f4e50ecc3ed">&#9670;&#160;</a></span>sdmap_shrink</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sdmap_shrink</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimize and shrink the map down as much as possible. </p>
<p>Average time complexity - <code>O(capacity)</code><br  />
 Calling this function invalidates all pointers retrieved with any function for this object in this library.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>Map to shrink </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac99abb33e73739188501f04327cd6b8e" name="ac99abb33e73739188501f04327cd6b8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac99abb33e73739188501f04327cd6b8e">&#9670;&#160;</a></span>SDMAP_SHRINK_DENOMINATOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SDMAP_SHRINK_DENOMINATOR&#160;&#160;&#160;4.0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default ratio of minimum capacity/count before an erase operation will trigger the map to be shrinked. </p>

</div>
</div>
<a id="ae441701f375f9a200aea81c465c2d8da" name="ae441701f375f9a200aea81c465c2d8da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae441701f375f9a200aea81c465c2d8da">&#9670;&#160;</a></span>sdmap_stack</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sdmap_stack</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">element_count&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stack-type simple dynamic map type generator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_type</td><td>Type of the key in the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value_type</td><td>Type of the value in the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element_count</td><td>Upper bound of elements in stack-type map.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Type to sdmap object that satisfies the input parameters </dd></dl>

</div>
</div>
<a id="a90aef422e096c1a030bfcc5c780c52c2" name="a90aef422e096c1a030bfcc5c780c52c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90aef422e096c1a030bfcc5c780c52c2">&#9670;&#160;</a></span>sdmap_traverse_inorder_keys</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sdmap_traverse_inorder_keys</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverse the map in order and look at keys. </p>
<p>Average time complexity - <code>O(capacity)</code><br  />
 Note that this function temporarily modifies the contents of the map inorder to traverse it effectively. This means that the entire map is invalid for the duration of the traversal and should not be looked at/modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>Map to traverse </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Function to call. Default prototype is <code>void (const void *key)</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user</td><td>(OPTIONAL) User pointer <code>(void *)</code>, if specified, then function prototype changes to <code>void (const void *key, void *user)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a1785d8573b9b1af793006080a0e7d8" name="a4a1785d8573b9b1af793006080a0e7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a1785d8573b9b1af793006080a0e7d8">&#9670;&#160;</a></span>sdmap_traverse_inorder_pairs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sdmap_traverse_inorder_pairs</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverse the map in order and look at both keys and values. </p>
<p>Average time complexity - <code>O(capacity)</code><br  />
 Note that this function temporarily modifies the contents of the map inorder to traverse it effectively. This means that the entire map is invalid for the duration of the traversal and should not be looked at/modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>Map to traverse </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Function to call. Default prototype is <code>void (const void *key, void *value)</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user</td><td>(OPTIONAL) User pointer <code>(void *)</code>, if specified, then function prototype changes to <code>void (const void *key, void *value, void *user)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b7117505991ec288cce345978dfb83c" name="a0b7117505991ec288cce345978dfb83c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b7117505991ec288cce345978dfb83c">&#9670;&#160;</a></span>sdmap_traverse_inorder_values</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sdmap_traverse_inorder_values</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverse the map in order and look at values. </p>
<p>Average time complexity - <code>O(capacity)</code><br  />
 Note that this function temporarily modifies the contents of the map inorder to traverse it effectively. This means that the entire map is invalid for the duration of the traversal and should not be looked at/modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>Map to traverse </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Function to call. Default prototype is <code>void (void *value)</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user</td><td>(OPTIONAL) User pointer <code>(void *)</code>, if specified, then function prototype changes to <code>void (void *value, void *user)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0217ef11d095b9aead6a94089ef9b4ed" name="a0217ef11d095b9aead6a94089ef9b4ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0217ef11d095b9aead6a94089ef9b4ed">&#9670;&#160;</a></span>sdmap_traverse_preorder_keys</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sdmap_traverse_preorder_keys</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverse the map in pre order and look at keys. </p>
<p>Average time complexity - <code>O(capacity)</code><br  />
 Note that this function temporarily modifies the contents of the map inorder to traverse it effectively. This means that the entire map is invalid for the duration of the traversal and should not be looked at/modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>Map to traverse </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Function to call. Default prototype is <code>void (const void *key)</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user</td><td>(OPTIONAL) User pointer <code>(void *)</code>, if specified, then function prototype changes to <code>void (const void *key, void *user)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c7cf928e5e3c5e880fd0c7b16cab8b1" name="a2c7cf928e5e3c5e880fd0c7b16cab8b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c7cf928e5e3c5e880fd0c7b16cab8b1">&#9670;&#160;</a></span>sdmap_traverse_preorder_pairs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sdmap_traverse_preorder_pairs</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverse the map in preorder and look at both keys and values. </p>
<p>Average time complexity - <code>O(capacity)</code><br  />
 Note that this function temporarily modifies the contents of the map inorder to traverse it effectively. This means that the entire map is invalid for the duration of the traversal and should not be looked at/modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>Map to traverse </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Function to call. Default prototype is <code>void (const void *key, void *value)</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user</td><td>(OPTIONAL) User pointer <code>(void *)</code>, if specified, then function prototype changes to <code>void (const void *key, void *value, void *user)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea7149f681bf40d37d2abe7974cc1cac" name="aea7149f681bf40d37d2abe7974cc1cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea7149f681bf40d37d2abe7974cc1cac">&#9670;&#160;</a></span>sdmap_traverse_preorder_values</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sdmap_traverse_preorder_values</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">map, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverse the map in preorder and look at values. </p>
<p>Average time complexity - <code>O(capacity)</code><br  />
 Note that this function temporarily modifies the contents of the map inorder to traverse it effectively. This means that the entire map is invalid for the duration of the traversal and should not be looked at/modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>Map to traverse </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Function to call. Default prototype is <code>void (void *value)</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user</td><td>(OPTIONAL) User pointer <code>(void *)</code>, if specified, then function prototype changes to <code>void (void *value, void *user)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9bfffa2bea0be7ffdf1677096718f72a" name="a9bfffa2bea0be7ffdf1677096718f72a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bfffa2bea0be7ffdf1677096718f72a">&#9670;&#160;</a></span>sdmap_typeof</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sdmap_typeof&#160;&#160;&#160;__typeof__</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A user-defineable macro that should have the same prototype and functionality as <code>__typeof__</code> </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
